# Authentication Module Overview

This document explains the internals of the authentication module so future maintainers can understand and extend the code base with confidence.

## 1. Responsibilities

- Provide JWT-based authentication (access and refresh tokens).
- Offer a lightweight token introspection API that only reports whether an access token is active.
- Manage registration, login, logout, email verification, forgot/reset password flows.
- Persist refresh tokens in Redis and verification/reset tokens in PostgreSQL.
- Deliver emails for verification and password reset through SMTP (processed asynchronously via Kafka).
- Expose `/me` endpoint to retrieve the current user profile.

## 2. Key Packages

| Package                      | Description                                                                     |
| ---------------------------- | ------------------------------------------------------------------------------- |
| `com.per.auth.controller`    | REST endpoints for auth flows and `/me`.                                        |
| `com.per.auth.service`       | Core business logic for auth, mail, and token management.                       |
| `com.per.auth.security`      | JWT utilities, filter chain, and user details integration with Spring Security. |
| `com.per.auth.service.token` | Abstractions for refresh tokens (Redis) and DB-backed single-use tokens.        |
| `com.per.common`             | Shared response envelope, error handling, and constants.                        |

## 3. Request Flow Summary

1. **Login (`POST /api/v1/auth/login`)**

   - `AuthController.login` delegates to `AuthService.login`.
   - Credentials authenticated via `AuthenticationManager`.
   - JWT pair generated by `JwtService`; refresh token stored in Redis.
   - Response: `AuthTokenResponse` exposing token fields only (user info fetched via `/me`).

2. **Authenticated Requests**

   - `JwtAuthenticationFilter` checks `Authorization` header.
   - Valid access token populates `SecurityContextHolder` (stateless session).

3. **Refresh (`POST /api/v1/auth/refresh`)**

   - Validates refresh JWT and Redis entry via `RefreshTokenService`.
   - Revokes supplied refresh token and issues a new pair (`AuthTokenResponse`).

4. **Introspect (`POST /api/v1/auth/introspect`)**

   - Accepts `IntrospectRequest { "accessToken": "<token>" }`.
   - `AuthService.introspect` verifies signature, token type, user status, and expiration.
   - Response data is a simple `{ "introspect": true|false }` while the message explains the result.

5. **Logout (`POST /api/v1/auth/logout`)**

   - Access token identifies the principal.
   - Refresh token is removed from Redis if present.

6. **Email Verification**

   - `UserTokenService.create` issues token type `EMAIL_VERIFICATION` (24h TTL).
   - `AuthService` publishes `EmailEvent` to Kafka topic `email-topic`.
   - `EmailConsumer` listens to topic and calls `MailService` to send email via SMTP.
   - `AuthService.verifyEmail` consumes token, marks `emailVerified = true`.

7. **Forgot/Reset Password**

   - `forgotPassword`: optionally creates `PASSWORD_RESET` token (15m TTL) and sends email.
   - `GET /reset-password?token=` validates token for client UI.
   - `resetPassword`: consumes token and updates BCrypt password.

8. **Current Profile (`GET /api/v1/auth/me`)**
   - `MeServiceImpl` loads user by username from security context and maps to `MeResponse`.

## 4. Token Lifecycles

- **Access Token**: 15 minutes, type `ACCESS`, contains user ID, roles, and issuer.
- **Refresh Token**: 30 days, type `REFRESH`, random JTI, stored in Redis for per-device revocation.
- **User Tokens**: DB-backed UUID tokens used for verification and password reset. Single-use with TTL enforced by `UserTokenServiceImpl`.

## 5. Persistence and Migrations

- Flyway migration `V1__init_schema.sql` creates tables (`users`, `roles`, `user_roles`, `user_tokens`) and seeds roles (`ADMIN`, `USER`).
- New schema changes must be added via additional migration files. Do not modify existing migrations.

## 6. Configuration Checklist

Define the following environment variables (see `.env.example`):

- `JWT_SECRET`, `ACCESS_TOKEN_TTL`, `REFRESH_TOKEN_TTL`, `JWT_ISSUER`
- `DB_URL`, `DB_USERNAME`, `DB_PASSWORD`
- `REDIS_HOST`, `REDIS_PORT`, `REDIS_PASSWORD` (optional)
- `MAIL_HOST`, `MAIL_PORT`, `MAIL_USERNAME`, `MAIL_PASSWORD`, `MAIL_FROM`
- `APP_BASE_URL`, `CORS_ALLOWED_ORIGINS`, `SERVER_PORT`

## 7. Extending the Module

- **Add new public endpoints**: update `SecurityConfig` permit list if they should bypass authentication.
- **Add admin-only endpoints**: annotate with `@PreAuthorize("hasRole('ADMIN')")` or suitable expression.
- **Introduce new token types**: extend `TokenType` enum and handle creation, validation, and consumption using `UserTokenService`.
- **Custom response codes**: register in `ApiSuccessCode`/`ApiErrorCode` to keep contracts consistent.
- **Modify email content**: update `MailServiceImpl`. Keep links controlled by `ApplicationProperties`.

## 8. Rate Limiting

Authentication endpoints are protected by Resilience4j rate limiters to prevent brute-force attacks:

| Instance | Endpoints | Description |
| --- | --- | --- |
| `authStrict` | `/register`, `/login`, `/reset-password` | High-risk operations |
| `authModerate` | `/refresh`, `/introspect` | Token management |
| `authVeryStrict` | `/verify-email`, `/forgot-password` | Sensitive operations |

When rate limits are exceeded, endpoints return `429 Too Many Requests`. Configuration values are environment-specific and should be tuned based on server capacity.

See [Rate Limiting Documentation](../../resilience-patterns/rate-limit/README.md) for details.

## 9. Testing Recommendations

- Unit test `AuthServiceImpl`, `JwtService`, and `UserTokenServiceImpl` with mocks for repositories and clock.
- Use Testcontainers for integration tests to cover login → refresh → logout flows with PostgreSQL and Redis.
- Verify email and reset flows using configured SMTP server (e.g., Gmail).

## 10. Operational Notes

- Redis key pattern: `auth:refresh:<token>` with TTL equal to refresh token duration.
- Spotless enforces formatting; run `./mvnw spotless:apply` before committing.
- Build validation: `./mvnw clean verify` (skips tests via `-DskipTests` during local iteration).
